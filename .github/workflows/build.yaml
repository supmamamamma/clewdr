# .github/workflows/release.yml

name: Build and Release Rust Binary (musl)

# 触发条件：当一个 tag 被推送到仓库时触发
on:
  push:
    tags:
      - 'v*' # 匹配例如 v1.0, v2.1.3 等 tag

# 所需权限：需要写入内容的权限来创建 Release 和上传文件
permissions:
  contents: write

jobs:
  build_and_release:
    # 运行环境：使用最新的 Ubuntu runner (因为需要 musl-tools)
    runs-on: ubuntu-latest
    steps:
      # 第一步：检出代码
      - name: Checkout code
        uses: actions/checkout@v4

      # 第二步：设置 Rust 工具链
      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable # 使用稳定版 Rust

      # 第三步：安装系统依赖项 (包括 musl-tools)
      - name: Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y git build-essential cmake perl pkg-config libclang-dev musl-tools g++
          # 安装 musl target 以进行静态链接构建
          rustup target add x86_64-unknown-linux-musl

      # 可选：缓存 Cargo 依赖项以加快构建速度
      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          # key 中加入 target 信息，避免与默认 target 冲突
          key: linux-musl-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}

      # 第四步：构建项目 (Release 模式, 使用 musl target)
      - name: Build Project
        # 使用 --target 进行 musl 静态链接构建
        run: cargo build --release --locked --target x86_64-unknown-linux-musl

      # 第五步：准备 Release 资源
      - name: Prepare Release Asset
        id: prepare_asset
        run: |
          # 从 github.repository (格式: owner/repo) 中提取仓库名
          REPO_NAME=$(echo "${{ github.repository }}" | awk -F / '{print $2}')
          # 获取触发工作流的 tag 名称
          TAG_NAME="${{ github.ref_name }}"

          TARGET_ARCH="x86_64"
          # 更新 OS 标识符以反映是 musl 构建
          TARGET_OS="linux-musl"

          # 二进制文件现在位于 musl target 的输出目录中
          SOURCE_BINARY_PATH_DIR="./target/x86_64-unknown-linux-musl/release"

          # 查找 target/x86_64-unknown-linux-musl/release 目录下的可执行文件
          SOURCE_BINARY_PATH=$(find "$SOURCE_BINARY_PATH_DIR" -maxdepth 1 -type f -executable -not -name '*.*' | head -n 1)

          # 如果找不到，尝试使用仓库名作为二进制文件名 (常见情况)
          if [ -z "$SOURCE_BINARY_PATH" ]; then
            FALLBACK_PATH="$SOURCE_BINARY_PATH_DIR/$REPO_NAME"
            if [ -f "$FALLBACK_PATH" ]; then
              SOURCE_BINARY_PATH="$FALLBACK_PATH"
              echo "Could not auto-detect binary, using fallback: $SOURCE_BINARY_PATH"
            else
              echo "Error: Could not find the executable binary in $SOURCE_BINARY_PATH_DIR/"
              echo "Please ensure your binary name is conventional or adjust the script."
              exit 1
            fi
          else
            echo "Found binary: $SOURCE_BINARY_PATH"
          fi

          # 资源文件名现在会包含 'linux-musl'
          ASSET_NAME="${REPO_NAME}-${TAG_NAME}-${TARGET_ARCH}-${TARGET_OS}"

          # 创建一个临时目录用于存放重命名的资源
          mkdir ./staging
          # 复制并重命名二进制文件
          cp "$SOURCE_BINARY_PATH" "./staging/${ASSET_NAME}"

          # 设置输出变量，供后续步骤使用
          echo "asset_path=./staging/${ASSET_NAME}" >> $GITHUB_OUTPUT
          echo "asset_name=${ASSET_NAME}" >> $GITHUB_OUTPUT
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "release_name=Release ${TAG_NAME}" >> $GITHUB_OUTPUT # Release 的标题
          # 可以自定义 Release 的描述信息，例如指向 CHANGELOG
          echo "body=Automatic release for tag ${TAG_NAME}. See CHANGELOG.md for details. (Linux binary is statically linked using musl)" >> $GITHUB_OUTPUT # 可选：在描述中说明是 musl 构建

      # 第六步：创建 GitHub Release 并上传资源
      - name: Create Release and Upload Asset
        uses: softprops/action-gh-release@v1
        with:
          # 从上一步获取的输出变量
          tag_name: ${{ steps.prepare_asset.outputs.tag_name }}
          name: ${{ steps.prepare_asset.outputs.release_name }}
          body: ${{ steps.prepare_asset.outputs.body }}
          # draft: false   # 设置为 true 可创建草稿 Release
          # prerelease: false # 设置为 true 可标记为预发布 Release
          # 指定要上传的文件，action 会使用这个文件的名称作为 Release 页面上的资源名
          files: ${{ steps.prepare_asset.outputs.asset_path }}
